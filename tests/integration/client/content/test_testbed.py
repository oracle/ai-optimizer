"""
Copyright (c) 2024, 2025, Oracle and/or its affiliates.
Licensed under the Universal Permissive License v1.0 as shown at http://oss.oracle.com/licenses/upl.
"""
# spell-checker: disable
# pylint: disable=import-error

from unittest.mock import patch


#############################################################################
# Test Streamlit UI
#############################################################################
class TestStreamlit:
    """Test the Streamlit UI"""

    # Streamlit File path
    ST_FILE = "../src/client/content/testbed.py"

    def test_initialization(self, app_server, app_test, monkeypatch):
        """Test initialization of the testbed component"""
        assert app_server is not None

        # Mock the API responses for get_models (both ll and embed types)
        def mock_get(endpoint=None, **kwargs):
            if endpoint == "v1/models":
                return [
                    {
                        "id": "test-ll-model",
                        "type": "ll",
                        "enabled": True,
                        "url": "http://test.url",
                        "openai_compat": True,
                    },
                    {
                        "id": "test-embed-model",
                        "type": "embed",
                        "enabled": True,
                        "url": "http://test.url",
                        "openai_compat": True,
                    },
                ]
            return {}

        monkeypatch.setattr("client.utils.api_call.get", mock_get)

        # Initialize app_test and run it to bring up the component
        at = app_test(self.ST_FILE)

        # Set up session state requirements
        at.session_state.user_settings = {
            "client": "test_client",
            "oci": {"auth_profile": "DEFAULT"},
            "vector_search": {"database": "DEFAULT"},
        }

        # Mock the available models that get_models would set
        at.session_state.ll_model_enabled = {
            "test-ll-model": {"url": "http://test.url", "openai_compat": True, "enabled": True}
        }

        at.session_state.embed_model_enabled = {
            "test-embed-model": {"url": "http://test.url", "openai_compat": True, "enabled": True}
        }

        # Populate the testbed_db_testsets in session state directly
        at.session_state.testbed_db_testsets = {}

        # Mock functions that make external calls to avoid failures
        monkeypatch.setattr("common.functions.is_url_accessible", lambda url: (True, ""))
        monkeypatch.setattr("streamlit.cache_resource", lambda *args, **kwargs: lambda func: func)
        monkeypatch.setattr("client.utils.st_common.is_db_configured", lambda: True)

        # Run the app - this is critical to initialize all widgets!
        at = at.run()

        # Verify specific widgets that we know should exist
        radio_widgets = at.get("radio")
        assert len(radio_widgets) == 1, "Expected 1 radio widget"

        button_widgets = at.get("button")
        assert len(button_widgets) >= 1, "Expected at least 1 button widget"

        file_uploader_widgets = at.get("file_uploader")
        assert len(file_uploader_widgets) == 1, "Expected 1 file uploader widget"

        # Test passes if the expected widgets are rendered

    def test_testset_source_selection(self, app_server, app_test, monkeypatch):
        """Test selection of test sets from different sources"""
        assert app_server is not None

        # Mock the API responses for get_models
        def mock_get(endpoint=None, **kwargs):
            if endpoint == "v1/models":
                return [
                    {
                        "id": "test-ll-model",
                        "type": "ll",
                        "enabled": True,
                        "url": "http://test.url",
                        "openai_compat": True,
                    },
                    {
                        "id": "test-embed-model",
                        "type": "embed",
                        "enabled": True,
                        "url": "http://test.url",
                        "openai_compat": True,
                    },
                ]
            return {}

        monkeypatch.setattr("client.utils.api_call.get", mock_get)

        # Mock functions that make external calls
        monkeypatch.setattr("common.functions.is_url_accessible", lambda url: (True, ""))
        monkeypatch.setattr("streamlit.cache_resource", lambda *args, **kwargs: lambda func: func)
        monkeypatch.setattr("client.utils.st_common.is_db_configured", lambda: True)

        # Initialize app_test
        at = app_test(self.ST_FILE)

        # Set up session state requirements
        at.session_state.user_settings = {
            "client": "test_client",
            "oci": {"auth_profile": "DEFAULT"},
            "vector_search": {"database": "DEFAULT"},
        }

        at.session_state.ll_model_enabled = {
            "test-ll-model": {"url": "http://test.url", "openai_compat": True, "enabled": True}
        }

        at.session_state.embed_model_enabled = {
            "test-embed-model": {"url": "http://test.url", "openai_compat": True, "enabled": True}
        }

        # Populate the testbed_db_testsets in session state directly
        at.session_state.testbed_db_testsets = {}

        # Run the app to initialize all widgets
        at = at.run()

        # Verify the expected widgets are present
        radio_widgets = at.get("radio")
        assert len(radio_widgets) > 0, "Expected radio widgets"

        file_uploader_widgets = at.get("file_uploader")
        assert len(file_uploader_widgets) > 0, "Expected file uploader widgets"

        # Test passes if the expected widgets are rendered

    @patch("client.utils.api_call.post")
    def test_evaluate_testset(self, mock_post, app_test, monkeypatch):
        """Test evaluation of a test set"""

        # Mock the API responses for get_models
        def mock_get(endpoint=None, **kwargs):
            if endpoint == "v1/models":
                return [
                    {
                        "id": "test-ll-model",
                        "type": "ll",
                        "enabled": True,
                        "url": "http://test.url",
                        "openai_compat": True,
                    },
                    {
                        "id": "test-embed-model",
                        "type": "embed",
                        "enabled": True,
                        "url": "http://test.url",
                        "openai_compat": True,
                    },
                ]
            return {}

        monkeypatch.setattr("client.utils.api_call.get", mock_get)

        # Mock API post response for evaluation
        mock_post.return_value = {
            "id": "eval123",
            "score": 0.85,
            "results": [{"question": "Test question 1", "score": 0.9}, {"question": "Test question 2", "score": 0.8}],
        }

        # Mock functions that make external calls
        monkeypatch.setattr("common.functions.is_url_accessible", lambda url: (True, ""))
        monkeypatch.setattr("streamlit.cache_resource", lambda *args, **kwargs: lambda func: func)
        monkeypatch.setattr("client.utils.st_common.is_db_configured", lambda: True)

        # Initialize app_test
        at = app_test(self.ST_FILE)

        # Set up session state requirements
        at.session_state.user_settings = {
            "client": "test_client",
            "oci": {"auth_profile": "DEFAULT"},
            "vector_search": {"database": "DEFAULT"},
        }

        at.session_state.ll_model_enabled = {
            "test-ll-model": {"url": "http://test.url", "openai_compat": True, "enabled": True}
        }

        at.session_state.embed_model_enabled = {
            "test-embed-model": {"url": "http://test.url", "openai_compat": True, "enabled": True}
        }

        # Run the app to initialize all widgets
        at = at.run()

        # For this minimal test, just verify the app runs without error
        # This test is valuable to ensure mocking works properly
        assert True

        # Test passes if the app runs without errors
